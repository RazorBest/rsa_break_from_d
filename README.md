# Decomposing public modulus N by knowing RSA private exponent d

In RSA, the public key is generated by taking two primes, p and q, and setting
N = p * q. Given n, it is a hard problem to find p and q in the right conditions.

Then, d is the inverse of the public exponent, e, modulo phi(n), where
phi(n) = phi(p * q) =  phi(p) * phi(q) = (p - 1) * (q - 1).

Similarly, d is hard to compute if we don't know the prime decomposition
of n. But if we know p and q, d becomes trivial to compute.

The question is: if d gets revealed, can we find p and q?

## The algorithm

Looking at the definition of d:
```
d = e^(-1) (mod phi(n))
d * e = 1 (mod phi(n))
```

Which can be written using the quotient remainder theorem:
```
d*e = c * phi(n) + 1, for some integer c
d*e - 1 = c * phi(n)
```

Let k = d * e - 1 = c * phi(n).

From Euler's theorem, we know that:
```
g^k = g^(d*e - 1) = g^(c*phi(n)) = (g^c)^(phi(n)) = 1 (mod n)
```

Until now, we used equations that were very common. The trick is the following:
look at g^(k/2).

Assuming p and q are non-trivial primes, then they are odd. This makes
phi(n) = (p - 1) * (q - 1) an even number. Then, we know that k / 2 can be
easily computed.

We will introduce this variable:
```
a = g^(k/2) (mod n)
```

Then we can say the following:
```
a^2 = g^k = 1 (mod n)
```

Which means that $a$ is a square root of 1. This refers to the known quadratic
residuosity problem. The theory says that for a prime p, the equation
a^2 = x (mod p) has either 0 or 2 solutions. Particularly, a^2 = 1 (mod p) has
 the solutions a = 1 and a = -1 (mod p).

But our modulus is not prime. It's a product of primes. However, equations
modulo n are also true modulo p and q. Here is a small proof:
```
Knowing:
n = p * q, where p is prime
e1 = e2 (mod n)

We will prove that e1 = e2 (mod p).

e1 = c * n + e2, for some integer c
e1 = (c * q) * p + e2
Let e2 = d * p + e3 be the decomposition of e2 divided by p (0 <= e3 < p), which is
equivalent to saying:
e2 = e3 (mod p)

Then:
e1 = (c * q) * p + d * p + e3 = (c * q + d) * p + e3

Since 0 <= e3 < p and (c * q + d) is an integer, we can rewrite this equation
using the modular equivalence:
e1 = e3 (mod p)

We just established earlier that e2 = e3 (mod p). Then:

e1 = e2 (mod p)
```

Using the result above, we can say that:
```
a^2 = 1 (mod p)
a^2 = 1 (mod q)
```

But, in each case, we have two solutions. For the first equation:
```
a = 1 (mod p)
or
a = -1 (mod p)
```
And
```
a = 1 (mod q)
or
a = -1 (mod q)
```
Since the results between p and q are independent, there are 4 possible
combinations. We will use the notation a = (x, y), meaning:
```
a = x mod p, for 0 <= x < p
and
a = y mod q, for 0 <= y < q
```

Then the possible combinations are:
```
a = (1, 1)
a = (1, -1)
a = (-1, 1)
a = (-1, -1)
```

Now, the last theorem that we need is the Chinese Remained Theorem. This
tells us that given some equalities modulo some numbers, if the numbers
are coprime, then there exists a unique solution modulo the product of
all the numbers, that satisfies the equation. In our case
```
Knowing:
a = x mod p
a = y mod q

Then:
a = z mod p * q, where z is uniquely determined from x, y, p and q.
```

This means that a = (x, y) can be mapped to exactly one element modulon n.

But (1, 1) and (-1, -1) are trivial to find.
```
a = (1, 1) leads to a = 1 (mod n)
a = (-1, -1) leads to a = -1 (mod n)
```
You can check that by looking at the solution and verify that it has the
expected values mod p and mod q.

However, a = (1, -1) and a = (-1, 1) have non-trivial solutions modulo n. In
fact, we should already know p and q to calculate them.

But earlier, we said that a, number which we can compute, is one of the square
roots of 1 modulon n: (1, 1) (-1, -1), (1, -1), (-1, 1).
And it is computed by taking an arbitrary g from the group, and setting a = g^(k / 2).

What we hope is that a = g^(k/2) is not a trivial root. For
example, let's assume that a = (1, -1). Which means:
```
a = 1 (mod p)
a = -1 (mod q)
```

Then:
```
a - 1 = 0 (mod p)
a - 1 = -2 (mod q)
```

Which means that a-1 is divisible by p, but not by q. This is perfect!
We can take the gcd(n, a-1) and we will get p. This goes similarly when
a = (-1, 1), in which case, gcd(n, a-1) will yield q.

What if a = 1? What we can try is to set a to:
```
a = g^(k/2^f) mod n, where f is the biggest integer such that 2^f divides k, and a^2 = 1 (mod n)
```

Let m = k / (2^(f+1)). Then g^m = 1 (mod n) and a = g^(m/2) is a square root of 1.

This finds an exponent for which a might not be 1. If a isn't a non-trivial root, choose
another g and try again.

What I can guarantee you is that it will take you a finite amount of expected tries to find
an a that is not a trivial square root.

At this point you have everything you need to write the algorithm in python.

But, maybe you're curios what's the success rate of this algorithm? What
if finding the correct g is also a hard task? The next section is dedicated
to answering this quation.

## The success rate of the algorithm

Let g be a random element from `Z_n*`.

Let `k = e*d - 1 = c*phi(n) = c*(p-1)*(q-1)`

Define m as following:
```
k = m * 2^(f-1), f is the maximal integer such that g^m = 1 (mod n), and m is even.
```

We want to know how many g's in Z/nZ, g^(m/2) is a non-trivial square root of 1.

We will need to look at the quadratic reciprocity property of g.

Assume that g is a quadratic non-residue modulo the prime p.

Then, g^phi()

```
g^m = g^(k / 2^(f-1)) = g^(c*phi(n) / 2^(f-1)) = 1 (mod n)
```

Let a = g^(m / 2).

### The condition for a != 1

Assume a = g^(m / 2) != 1 (mod n)

```
g^(m/2) != 1 (mod n)
```

Then:
```
g^(m/2) != 1 (mod p)
or 
g^(m/2) != 1 (mod q)
```

Without loss of generality, assume that the first equation is true:
```
g^(m/2) != 1 (mod p)
```

But g^(m/2) is a square root of 1 modulo p. The only possibility is:
```
g^(m/2) = -1 (mod p)
```

But `g^m = 1 (mod n)`:
Meaning that:
```
g^m = 1 (mod p)
```

Let `o_p` = ord(g, p), the order of g, modulo p.

Then, `o_p` must divide m:
```math
m = k*o_p, for an integer k
```

From the first equation, `o_p` can't divide m/2. This is possible only
if k is odd. Otherwise, we could write `m/2 = (k/2)*o_p`.

If m is even and k is odd, then `o_p` must be even.

This is the only condition needed. There are phi(p) * (1 - 1 / 2^(v_2(phi(p)))) elements
of even order modulo p. v_2(p) is the 2-adic valuation of phi(p).

So, the chance that g^(m/2) = -1 (mod p) is (1 - 1 / 2^(v_2(phi(p)))).
Similarly, the chance that g^(m/2) = -1 (mod q) is (1 - 1 / 2^(v_2(phi(q)))).

The chance of finding a non-trivial square root is the chance that g^(m/2) = 1 (mod p)
and g^(m/2) = -1 (mod q) added with the chance that g^(m/2) = -1 (mod p) and g^(m/2) = 1 (mod q).

```
P = (1 - 1 / 2^(v_2(phi(p))))*(1 / 2^(v_2(phi(q)))) + (1 / 2^(v_2(phi(p))))*(1 - 1 / 2^(v_2(phi(q)))) =
= (2^v_2(phi(p)) - 1) / 2^(v_2(phi(p))+v_2(phi(q))) + (2^v_2(phi(q)) - 1) / 2^(v_2(phi(p)+v_2(phi(q)))) =
= (2^v_2(phi(p)) + 2^v_2(phi(q)) - 2) / 2^v_2(phi(n))

phi(p) is even. Then, 2^v_2(phi(p)) >= 2.
2^v_2(phi(p)) - 2 >= 0

P >= 2^v_2(phi(q)) / 2^v_2(phi(n)) = 2^v_2(phi(q)/phi(n)) = 2^v_2(1/phi(p)) = 2^(-v_2(phi(p))) = 1/2^v_2(phi(p))
```

### Looking at quadratic residues

In the algorithm, we look at $g^{k / 2^f} mod n$ until it's value is not 1 anymore, or until the division can't be done anymore.
Let's lay out each iteration by looking at:
```math
m_x = k / 2^x
```

Let $m = m_f$, such that either m is odd or $g^{m/2} = 1 (mod n)$.

We will look at some interesting values of $m_x$. First, rewrite k by getting
the powers of 2 away:
```math
Define integers a and r: \phi(p) = 2^a \cdot r, r is odd
Define ingeters b and s: \phi(q) = 2^b \cdot s, s is odd
Define integers d and t: c = 2^d \cdot t, t is odd
```
Without loss of generality, assume a <= b.
```math
k = c \cdot phi(n) = c * phi(p) \cdot phi(q) = 2^{a+b+d} \cdot rst
```

### Analysing x <= d + a
For $x <= d + a$, $g^m_x = 1 (mod n)$. To prove that, we look at the values modulo p and q:
```math
x <= d + a \rightarrow m_x = d + a - \Delta, \Delta \geq 0
m_x = k / 2^x = \frac{2^{a+b+d} \cdot rst}{2^{d+a-\Delta}} = 2^{b+\Delta}\cdot rst
```
Rewriting according to q:
```math
m_x = 2^\Delta \cdot rt \cdot 2^b\cdot s = 2^\Delta\cdot rt\phi(q)
g^m_x = g^{2^\Delta\cdot rt\phi(q)} = 1 (mod q) (Euler's theorem)
```
Rewriting according to p:
```math
m_x = 2^{\Delta+b-a} \cdot st \cdot 2^a\cdot r = 2^{\Delta+b-a}cdot rt\phi(p), b-a>=0
g^m_x = g^{2^{\Delta+b-a}cdot rt\phi(p)} = 1 (mod p) (Euler's theorem)
```

From the two equations, we can use apply the CRT for `n = p\cdot q`:
```math
g^m_x = 1 (mod n)
```

Next, we'll look at x = d + a + 1. However, it will be split in two cases: when a = b, and when a < b.

### First case: a < b

Let x = d + a + 1

If $a < b$, then $a <= b - 1$. We can write $b-1$ as $b - 1 = a + \Delta, \Delta >= 0$.

```math
m_x = 2^{b - 1} \cdot rst = 2^{a + \Delta}\cdot rst
```
Looking at the $g^m_x mod p$:
```math
g^m_x = g^{2^{\Delta} \cdot st 2^{a} \cdot r} = g^{2^\Delta\cdot st \phi(p)} = 1 (mod p)
```

However, for mod p, the two's exponent is two small, as $rst$ is odd.
Multiplying by two should be enough to get $\phi(q)$:
```math
m_x = rt\cdot 2^b\cdot s / 2 = rt\cdot phi(q) / 2
```

What we hope is that g is a quadratic non-residue mod q. Assuming this, and using Euler's criterion and the fact that $rt$ is odd:
```math
g^m_x = g^{rt\cdot phi(q) / 2} = (g^{phi(q) / 2})^{rt} = (-1)^rt = -1 (mod q)
```

This is great! We've got a value that's 1 mod p and -1 mod q, which we can also compute modulo n.
This will be a non-trivial square root.

However, this happends only when g is a quadratic non-residue mod q. Half of the elements are non-residues.

So, the chance of this happening, when a < b, is 1/2.

### Second case: a = b

Let x = d + a + 1

This case is a little different, because we can't guarantee that $g^m_x$ will be 1 mod p or 1 mod q.
But there is still a chance.

```math
m_x = 2^{b-1} \cdot rst
```

Now, we'll assume that g is a quadratic residue mod p, and a quadratic non-residue mod q.
Express $m_x$ using $\phi(p)$:
```math
m_x = 2^{b} \cdot rst / 2 = st \phi(p) / 2
```
Using Euler's criterion:
```math
g^m_x = g^{st \phi(p) / 2} = (g^{\phi(p) / 2})^{st} = 1^{st} = 1 (mod p)
```

Then, express $m_x$ using $\phi{q}$
```math
m_x = 2^{b} \cdot rst / 2 = rt \phi(q) / 2
```
Using Euler's criterion, and the fact that $st$ is odd:
```math
g^m_x = g^{rt \phi(q) / 2} = (g^{\phi(q) / 2})^{rt} = (-1)^{st} = -1 (mod q)
```

This means that $g^{m_x}$ is a non-trivial square root mod n.

Conversely, we can also assume that g is a quadratic non-residue mod q, and a quadratic residue mod q.

Since the value of $g$ mod p and mod q are independent, we can just multiply the porbabilities. Meaning
that, if we know $g mod p$, this doesn't tell us anything about $g mod q$, because of CRT.

The chance of g having different residucity mod p and q is:
```
\frac{1}{2}\cdot\frac{1}{2} + \frac{1}{2}\cdot\frac{1}{2} = \frac{1}{2}
```

### Conclusion

We can conclude that, when x <= d + a, $g^m_x = 1 (mod n)$. Also $m_x$ is even, because $b > 0$.
So the algorithm won't because k can't be divided anymore. But $g^m_x/2 = g^{m_{x+1}}$, for which x+1 = a+b+1.
There is a $1/2$ chance that this will be a non-trivial root.

The algorithm can continue after $x = d + a$ with a 50% chance. And the probability could be tightened up,
depending on the values of a and b, and looking at 2th power residues. But the  bound is good enough, because,
in case of failure, the algorithm retries with a new g.

The expected number of g's to be tried is less than 2.

To have a 0.999 probability of success, 10 trials are enough.

# The solutions of x^m - a = 0 (mod p)

If p is prime, then x^m - a = 0 has gcd(m, p - 1) distinct solutions.

Let p = 7, m = 5, and a = 1.

All operations modulo 7:
0^5 = 0
1^5 = 1
2^5 = 4
3^5 = 5
4^5 = 2
5^5 = 3
6^5 = 6

Let g be a generator of the prime group.
Express a and x according to the generator: a = g^b, x = g^y.
(g^y)^m = g^b (mod p)
ym = b (mod p-1)

If gcd(m, p-1) = 1, m is invertible, and y = b * m^-1 (mod p-1)

Otherwise, let d = gcd(m, p-1). Let m = k1 * d, and p-1 = k2 * d. Then, gcd(k1, k2) = 1, and gcd(m, k2) = 1.

y*m = c*(p-1) + b, for some integer c

y * m = c * k2 * d + b
y * m = b (mod k2)

Now, gcd(m, k2) = 1. Then, y = b * m^-1 (mod k2).

Taking the initial equation modulo d:

ym = b (mod d)
But m = k1 * d ==> ym = y * k1 * d = 0 (mod d) and b = 0 (mod d).

So, for the equation to satisfy, d must divide b.

Apart from that, the equation doesn't give any information about y. In fact,
y can be anything, and the equation modulo d would still hold.

Then, we can choose y = z (mod d), wlog.

Then, with CRT:
y = b * m^-1 (mod k2)
y = z (mod d)

We can uniquely determine y mod d * k2, where d * k2 = p - 1.

However, there are d choices for z. So, y will have d solutions.

If gcd(m, p - 1) divides b, then the number of solutions for x^m - a = 0 (mod p) is gcd(m, p - 1).

---

# The number a is an mth power residue modulo p, if and only if a^(phi(p)/gcd(m, phi(p))) = 1 (mod p)

Reference: Ireland & Rosen 4.2.1

We will express the elements using a generator of `Z_p*`. Let g be such a generator. We remind its properties:
   - The order of g is p-1 i.e. the equation g^m = 1 (mod p) has m = phi(p) the smallest non-zero solution.
   - Any element in the group can be expressed as g^x, for x in [0, phi(p)].
   - If g^x = g^y (mod p)  ==> x = y (mod phi(p))


## Right to left: a being an mth power residue implies a^(phi(p)/gcd(m, phi(p))) = 1 (mod p) 

Let `d = gcd(m, phi(p))`. Let m = k * d, for some integer k.

If a is an mth power residue:
```
x^m = a (mod p)
```
Then:
```
a^(phi(p)/gcd(m, phi(p))) = a^(phi(p)/d) = (x^m)^(phi(p)/d) = x^(m*phi(p)/d) = x^(k*d*phi(p)/d) = x^(k*phi(p)) = 1 (mod p)
```

# Left to right: if a^(phi(p)/gcd(m, phi(p))) = 1 (mod p), then a is an mth power residue

Let `d = gcd(m, phi(p))` and m = k * d for some integer k. We know that gcd(k, phi(p)) = 1. Otherwise, d could be bigger.

Let g be a generator of `Z_p*`.

Let `g^b = a (mod p)`.

Then, the equation:
```
a^(phi(p)/d) = 1 (mod p)
```
Implies:
```
g^(b*phi(p)/d) = g^0 (mod p)
b*phi(p)/d = 0 (mod phi(p))
```

Meaning that phi(p) divides `b*phi(p)/d`. This means that b/d is an integer,
so d divides b.
```
b = c * d, for some integer c. However, c might not be unique.
```
Then:
```
a = g^b = (g^c)^d (mod p)
```

From before, we know that h^k = g^c (mod p) and gcd(m, phi(p)) divides c, then h has gcd(k, phi(p)) distinct solutions.

Since gcd(m, phi(p)) = 1, h can be uniquely determined from g, c, and k.
Now we can rewrite a:
```
a = (g^c)^d = (h^k)^d = h^(k*d) = h^m (mod p)
```
Which shows that h is the mth root of a. Then, a is an mth power residue.

---

# If g is a quadtratic residue modulo p, then, in can't be a generator, for p > 2

For g to be a generator, the smallest non-zero m such that g^m = 1 (mod p) should be p - 1.

If g is a quadratic residue, then x^2 = g (mod p).

But then (applying Euler's theorem):
    g^((p-1) / 2) = (x^2)^((p-1) / 2) = x^(p-1) = 1 (mod p)

But (p-1) / 2 < p - 1. So g can't be a generator.

---

# If g is an dth power residue modulo p, for a divisor d > 1 of phi(p), g can't be a generator, for p > 2

This is identical to the proof for quadtratic residues. This is a generalization.

Assume g is a generator. Then, the smallest non-zero m for g^m = 1 (mod p) is m = phi(p).

If g is a dth power residue, then:
```
g^(phi(p) / gcd(d, phi(p))) = g^(phi(p)/d) = 1 (mod p)
```

If d > 1, then phi(p) / d  < phi(p), which contradicts with g being a generator.

---

# If, for any divisor d > 1 of phi(p), h is not a dth power residue mod p, then h is a generator, for p > 2

For h to be a generator, h^m = 1 (mod p) has to have the smallest non-zero solution m = phi(p).

Asssume there exists n < phi(p) such that h^n = 1 (mod p), and n is minimal.
The powers of h generate a subgroup of size n. From Lagrange's theorem, we know that the size of the subgroup must divide the size of the parent group `Z_p*`.

Since `|z_p*| = phi(p)`, n divides phi(p). This means that `d = phi(p)/n` is a divisor of phi(p). Conversely, `n = phi(p)/d`
Knowing that n < phi(p), then d > 1.

Looking back at the equation satisfied by n:
```
h^n = h^(phi(p)/d) = 1 (mod p)
```

This means that h is a dth power residue, which contradicts with the hypothesis.
So, we can say that the smallest m such that h^m = 1 (mod p) is phi(p). In conclusion, h is a generator of `Z_p*`.  

```
g^m = g^0 (mod p)
m = 0 (mod phi(p))
```

---

# The number of generators modulo p is phi(phi(p)).

We can prove this by using the last two lemmas.

## Upper bound

The first lemma gives us an upper bound:
> If g is an dth power residue modulo p, for a divisor d > 1 of phi(p), g can't be a generator
Using its negation:
> If g is a generator, then g is not a dth power residue modulo p, for any divisor d > 1 of phi(p)

Let h be a generator. Then {h^0, h^1, ..., h^phi(p)} is `Z_p*`.

Assume gcd(m, phi(p)) = d. d > 1, and m = k * d, for some integer k.
```
h^m = = h^(k*d) = (h^k)^d (mod p)
```
Which means that h^m is a dth power residue. The number of such m's, for d > 1,
is exactly phi(p) - phi(phi(p)). That's because phi(phi(p)) counts the numbers
m for which gcd(m, phi(p)) = 1.

So, we know that out of phi(p), phi(p) - phi(phi(p)) numbers in `Z_p*` can't
be generators.

```
number of generators <= phi(phi(p))
```

## Lower bound

Using the second lemma:
> If, for any divisor d > 1 of phi(p), h is not a dth power residue mod p, then h is a generator, for p > 2

Again, taking a generator h, and looking at {h^0, ..., h^phi(p)}, if h^m is not
a power residue, we can say that gcd(m, phi(p)) = 1.
Then, h^m is a generator. The amount of numbers m such that gcd(m, phi(p)) = 1 is phi(phi(p)).

````
phi(phi(p)) <= number of generators
```

## Conclusion

Using the 2 bounds, we can conclude that the number of generators is phi(phi(p)).
