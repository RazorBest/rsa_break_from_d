# Decomposing public modulus N by knowing RSA private exponent d

In RSA, the public key is generated by taking two primes, p and q, and setting
N = p * q. Given n, it is a hard problem to find p and q in the right conditions.

Then, $d$ is the inverse of the public exponent, $e$, modulo $\phi(n)$, where
$\phi(n) = \phi(pq) = \phi(p) \cdot \phi(q) = (p - 1)(q - 1)$.

Similarly, d is hard to compute if we don't know the prime decomposition
of n. But if we know p and q, d becomes trivial to compute.

The question is: if d gets revealed, can we recover p and q?

## The algorithm construction

If you don't need to understand how the algorithm works, you can jump straight to the [Source Code](#the-source-code).

Looking at the definition of $d$:
```math
\begin{align*}
& d \equiv e^{-1} \ (\text{mod } \phi(n)) \\
& de \equiv 1 \ (\text{mod } \phi(n))
\end{align*}
```

Which can be written using the quotient remainder theorem:
```math
\begin{align*}
& de = c \cdot \phi(n) + 1, \text{ for some integer c} \\
& de - 1 = c \cdot phi(n)
\end{align*}
```

Let $k = de - 1 = c \cdot \phi(n)$.

From Euler's theorem, we know that:
```math
g^k \equiv g^{c\cdot \phi(n)} \equiv (g^c)^{\phi(n)} \equiv 1 \ (\text{mod } n) 
```

Until now, we used equations that were very common. The trick is the following:
look at $g^{k/2}$.

Assuming p and q are non-trivial primes, then they are odd. This makes
$\phi(n) = (p - 1)(q - 1)$ an even number. Then, we know that $k / 2$ can be
easily computed.

We will introduce the variable $a$:
```math
a \equiv g^{k/2} \ (\text{mod } n) 
```

Then we can say the following:
```math
a^2 \equiv g^k = 1 \ (\text{mod } n) 
```

Which means that $a$ is a square root of 1. This refers to the known quadratic
residuosity problem. The theory says that for a prime p, the equation
$a^2 \equiv x \ (\text{mod } p)$ has either 0 or 2 solutions in $a$. Particularly, $a^2 \equiv 1 \ (\text{mod } p)$ has the solutions $a \equiv 1 \ (\text{mod } p)$ and $a \equiv -1 \ (\text{mod } p)$.

But our modulus is not prime. It's a product of primes. However, equations
modulo n are also true modulo p and q:
```math
\begin{align*}
& a^2 = 1 (\text{mod } p) \\
& a^2 = 1 (\text{mod } q)
\end{align*}
```

But, in each case, we have two solutions. For the first equation:
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } p) \\
& \text{or} \\
& a \equiv -1 \ (\text{mod } p)
\end{align*}
```
And
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } q) \\
& \text{or} \\
& a \equiv -1 \ (\text{mod } q)
\end{align*}
```
Since the results between p and q are independent, there are 4 possible
combinations. We will use the notation a = (x, y), meaning:
```math
\begin{align*}
& a \equiv x \ (\text{mod } p), \text{ for } 0 \leq x < p \\
& \text{and} \\
& a \equiv y \ (\text{mod } q), \text{ for } 0 \leq y < q
\end{align*}
```

Then the possible combinations are:
```math
\begin{align*}
& a = (1, 1) \\
& a = (1, -1) \\
& a = (-1, 1) \\
& a = (-1, -1)
\end{align*}
```

Now, the last theorem that we need is the Chinese Remained Theorem (CRT). This
tells us that given some equalities modulo some numbers, if the numbers
are coprime, then there exists a unique solution modulo the product of
all the numbers, that satisfies the equation.

In our case, knowing:
```math
\begin{align*}
& a \equiv x \ (\text{mod } p) \\
& a \equiv y \ (\text{mod } q) \\
\end{align*}
```
Then:
```math
a \equiv z \ (\text{mod } pq), \text{  where z is uniquely determined from x, y, p and q}
```

This means that a = (x, y) can be mapped to exactly one element modulo n.

But (1, 1) and (-1, -1) are trivial to find.
```math
\begin{align*}
& a = (1, 1) \text{ leads to } a \equiv 1 \ (	\text{mod } n) \\
& a = (-1, -1) \text { leads to } a \equiv -1 \ (	\text{mod } n) 
\end{align*}
```
You can check that by looking at the solution and verify that it has the
expected values mod p and mod q.

However, a = (1, -1) and a = (-1, 1) have non-trivial solutions modulo n. In
fact, we should already know p and q to calculate them.

But earlier, we said that $a$, which we can compute, is one of the square
roots of 1 mod n: $(1, 1)$, $(-1, -1)$, $(1, -1)$, $(-1, 1)$.
And it is computed by taking an arbitrary $g$ from the group, and setting $a = g^{k/2}$.

What we hope is that $a = g^{k/2}$ is not a trivial root. For
example, let's assume that $a = (1, -1)$. Which means:
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } p) \\
& a \equiv -1 \ (\text{mod } q)
\end{align*}
```

Then:
```math
\begin{align*}
& a - 1 \equiv 0 \ (\text{mod } p) \\
& a - 1 \equiv -2 \ (\text{mod } q)
\end{align*}
```

Which means that $a-1$ is divisible by $p$, but not by $q$. This is perfect!
We can take the gcd($n$, $a-1$) and we will get $p$. This goes similarly when
$a = (-1, 1)$, in which case, gcd($n$, $a-1$) will yield $q$.

What if $a = 1$? What we can try is to set $a$ to:
```math
\begin{align*}
& a = g^{k/2^f} \text{ mod } n, \\
& \text{where } f \text{ is the biggest integer such that } 2^f \text{ divides } k, \\
& \text{and } a^2 \equiv 1 \ (	\text{mod } n) 
\end{align*}
```

Let $m = k / (2^{f-1})$. Then $g^m = 1 \ (	\text{mod } n)$  and $a = g^{m/2}$ is a square root of 1.

This process finds an exponent for which $a$ might not be 1. If $a$ isn't a non-trivial root, choose
another g and try again.

What I can guarantee is that it will take you a finite amount of expected trials to find
a non-trivial square root.

At this point you have everything you need to write the python algorithm. You can jump directly to the [Source Code](#the-source-code).

But, maybe you're curios what's the success rate of this algorithm. What
if choosing the right g is also a hard task? The next section is dedicated
to answering this question.


---


## The runtime of the algorithm

Let g be a random element from $\mathbb{Z}_n^*$.

Let $k = ed - 1 = c\phi(n) = c(p-1)(q-1)$.

In the algorithm, we look at $g^{k / 2^f} \ (\text{mod } n)$ until its value is not 1, or until the division can't be done anymore.
Each iteration step can be described by:
```math
\begin{align*}
& m_x = k / 2^x,\ x \geq 0 \\
& m_x / 2 = m_{x+1}
\end{align*}
```
And the iteration stops when $m_{x+1}$ is odd or $g^{m_{x}/2} \equiv 1\ (\text{mod } n)$

Let $m = m_f$, such that either m is odd or $g^{m/2} = 1 (\ (	ext{mod } n) )$.

We will look at some interesting values of $m_x$. First, rewrite k by extracting the powers of 2 outside:
```math
\begin{align*}
&\text{Let } a, r\in \mathbb{Z}: \phi(p) = 2^a \cdot r, r \text{ is odd} \\
&\text{Let } b, s\in \mathbb{Z}: \phi(q) = 2^b \cdot s, s \text{ is odd} \\
&\text{Let } d, t\in \mathbb{Z}: c = 2^d \cdot t, t \text{ is odd}
\end{align*}
```
Without loss of generality, assume $a \leq b$.
```math
k = c \cdot \phi(n) = c \cdot \phi(p) \cdot \phi(q) = 2^{a+b+d} \cdot rst
```

### Analysing x <= d + a
If $x <= d + a$, then $g^{m_x} \equiv 1 \ (\text{mod } n)$.

To prove that, we look at the value of $g^{m_x}$ modulo p and q:
```math
\begin{align*}
& x \leq d + a \rightarrow x = d + a - \Delta, \Delta \geq 0 \\
& m_x = k / 2^x = \frac{2^{a+b+d} \cdot rst}{2^{d+a-\Delta}} = 2^{b+\Delta}\cdot rst
\end{align*}
```
Rewriting according to q:
```math
\begin{align*}
& m_x = 2^\Delta \cdot rt \cdot 2^b\cdot s = 2^\Delta rt\cdot \phi(q) \\
& g^{m_x} \equiv g^{2^\Delta rt\cdot \phi(q)} \equiv 1 \ (\text{mod } q) \text{ (Euler's theorem)}
\end{align*}
```
Rewriting according to p:
```math
\begin{align*}
& m_x = 2^{\Delta+b-a} \cdot st \cdot 2^a r = 2^{\Delta+b-a} rt\cdot \phi(p), b-a>=0 \\
& g^{m_x} \equiv g^{2^{\Delta+b-a} rt\cdot \phi(p)} \equiv 1 \ (\text{mod } p) \text{ (Euler's theorem)}
\end{align*}
```

From the two equations:
```math
\begin{align*}
& g^{m_x} \equiv 1 \ (	\text{mod } p) \\
& g^{m_x} \equiv 1 \ (	\text{mod } q) 
\end{align*}
```
we can apply the CRT for $n = p\cdot q$:
```math
g^{m_x} \equiv 1 \ (	\text{mod } n) 
```

Next, we'll look at $x = d + a + 1$. However, it will be split in two cases: $a = b$, and $a < b$.

### First case: a < b

Let $x = d + a + 1$.

If $a < b$, then $a <= b - 1$. We can write $b-1$ as $b - 1 = a + \Delta, \Delta >= 0$.

```math
m_x = 2^{b - 1} \cdot rst = 2^{a + \Delta}\cdot rst
```
Looking at $g^{m_x} \text{ mod } p$:
```math
g^{m_x} \equiv g^{2^{\Delta} \cdot st 2^{a} \cdot r} \equiv g^{2^\Delta st\cdot  \phi(p)} \equiv 1 \ (\text{mod } p)
```

However, for mod q, the two's exponent is too small, as $rst$ is odd.
Multiplying by 2 should be enough to get back to $\phi(q)$:
```math
m_x = rt\cdot 2^b s / 2 = rt\cdot \phi(q) / 2
```

What we hope is that g is a quadratic non-residue mod q. Assuming this, and using Euler's criterion and the fact that $rt$ is odd:
```math
g^{m_x} \equiv g^{rt\cdot phi(q) / 2} \equiv (g^{phi(q) / 2})^{rt} \equiv (-1)^{rt} \equiv -1 \ (\text{mod } q)
```

This is great! We've got a value that's 1 mod p and -1 mod q, which we can also compute modulo n.
This will be a non-trivial square root.

However, this happens only when g is a quadratic non-residue mod q. Half of the elements are non-residues.

So, the chance of this happening, when a < b, is 1/2.

### Second case: a = b

Let x = d + a + 1

This case is a little different, because we can't guarantee that $g^m_x$ will be 1 mod p or 1 mod q.
However, there is still a chance.

```math
m_x = 2^{b-1} \cdot rst
```

Now, we'll assume that g is a quadratic residue mod p, and a quadratic non-residue mod q.
Express $m_x$ using $\phi(p)$:
```math
m_x = 2^{b} \cdot rst / 2 = st \cdot \phi(p) / 2
```
Using Euler's criterion:
```math
g^{m_x} \equiv g^{st \cdot \phi(p) / 2} \equiv (g^{\phi(p) / 2})^{st} \equiv 1^{st} \equiv 1 \ (\text{mod } p)
```

Then, express $m_x$ using $\phi(q)$
```math
m_x = 2^{b} \cdot rst / 2 = rt \cdot \phi(q) / 2
```
Using Euler's criterion, and the fact that $st$ is odd:
```math
g^{m_x} \equiv g^{rt \cdot \phi(q) / 2} \equiv (g^{\phi(q) / 2})^{rt} \equiv (-1)^{st} \equiv -1 \ (\text{mod } q)
```

This means that $g^{m_x}$ is a non-trivial square root mod n.

Conversely, we can also assume that g is a quadratic non-residue mod q, and a quadratic residue mod q.

Since the value of $g$ mod p and mod q are independent because of the CRT, we can just multiply the porbabilities.

The chance of g having different residucity mod p and q is:
```math
\frac{1}{2}\cdot\frac{1}{2} + \frac{1}{2}\cdot\frac{1}{2} = \frac{1}{2}
```

## Conclusion

We can conclude that, when $x <= d + a$, $g^{m_x} = 1 \ (	\text{mod } n) $. Also $m_x$ is even, because $b > 0$.
So the algorithm won't stop because k can't be divided anymore. But $g^m_x/2 = g^{m_{x+1}}$, for which x+1 = a+b+1.
There is a $1/2$ chance that $g^{m_{x+1}}$ will be a non-trivial root.

The algorithm can continue after $x = d + a$ with a 50% chance. And the probability could be tightened up,
depending on the values of a and b, and looking at 2th power residues. But the bound is good enough, because,
in case of failure, the algorithm retries with a new g.

The expected number of g's to be tried is less than 2.

To have a 0.999 probability of success, 10 trials are enough.

# The source code
```python
from itertools import combinations
from math import gcd
from random import randint


def break_rsa_from_d(n: int, e: int, d: int):
    k = d*e - 1

    while True:
        g = random.randint(1, n - 1)
        # This is just a mathematical check
        # The chance for this to happen is roughly 2*sqrt(n)/n. Negligible for n >= 1024.
        if (gcd(g, n)) != 1:
            p = gcd(g, n)
            return p, n // p

        # g**k must always be 1
        # assert pow(g, k, n) == 1
        
        f = 1
        while k % 2**(f+2) == 0 and pow(g, k // 2**(f + 1), n) == 1:
            f += 1

        m = k // (2**f)

        root = pow(g, m // 2, n)

        # From the construction, root is  a square root of 1.
        # In Z_n, for n = p * q, the square root of 1 has 4 different solutions
        # Two of the solutions are 1 and -1. The other two are called non-trivial solutions.
        # We wan't to find a non-trivial square root of 1.

        if root != n - 1 and root != 1:
            p = gcd(n, root - 1)
            # assert p > 1
            return p, n // p


def main():
    p = 29619082031781708758789445286032309089689245581404437540274962433
    q = 36201100261066532927409322016261711109620189043938756993669398529
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 13
    d = pow(e, -1, phi)

    print(break_rsa_from_d(n, e, d))


if __name__ == "__main__":
    main()
```

# The solutions of x^m - a = 0 (mod p)

If p is prime, then x^m - a = 0 has gcd(m, p - 1) distinct solutions.

Let p = 7, m = 5, and a = 1.

All operations modulo 7:
0^5 = 0
1^5 = 1
2^5 = 4
3^5 = 5
4^5 = 2
5^5 = 3
6^5 = 6

Let g be a generator of the prime group.
Express a and x according to the generator: a = g^b, x = g^y.
(g^y)^m = g^b (mod p)
ym = b (mod p-1)

If gcd(m, p-1) = 1, m is invertible, and y = b * m^-1 (mod p-1)

Otherwise, let d = gcd(m, p-1). Let m = k1 * d, and p-1 = k2 * d. Then, gcd(k1, k2) = 1, and gcd(m, k2) = 1.

y*m = c*(p-1) + b, for some integer c

y * m = c * k2 * d + b
y * m = b (mod k2)

Now, gcd(m, k2) = 1. Then, y = b * m^-1 (mod k2).

Taking the initial equation modulo d:

ym = b (mod d)
But m = k1 * d ==> ym = y * k1 * d = 0 (mod d) and b = 0 (mod d).

So, for the equation to satisfy, d must divide b.

Apart from that, the equation doesn't give any information about y. In fact,
y can be anything, and the equation modulo d would still hold.

Then, we can choose y = z (mod d), wlog.

Then, with CRT:
y = b * m^-1 (mod k2)
y = z (mod d)

We can uniquely determine y mod d * k2, where d * k2 = p - 1.

However, there are d choices for z. So, y will have d solutions.

If gcd(m, p - 1) divides b, then the number of solutions for x^m - a = 0 (mod p) is gcd(m, p - 1).

---

# The number a is an mth power residue modulo p, if and only if a^(phi(p)/gcd(m, phi(p))) = 1 (mod p)

Reference: Ireland & Rosen 4.2.1

We will express the elements using a generator of `Z_p*`. Let g be such a generator. We remind its properties:
   - The order of g is p-1 i.e. the equation g^m = 1 (mod p) has m = phi(p) the smallest non-zero solution.
   - Any element in the group can be expressed as g^x, for x in [0, phi(p)].
   - If g^x = g^y (mod p)  ==> x = y (mod phi(p))


## Right to left: a being an mth power residue implies a^(phi(p)/gcd(m, phi(p))) = 1 (mod p) 

Let `d = gcd(m, phi(p))`. Let m = k * d, for some integer k.

If a is an mth power residue:
```
x^m = a (mod p)
```
Then:
```
a^(phi(p)/gcd(m, phi(p))) = a^(phi(p)/d) = (x^m)^(phi(p)/d) = x^(m*phi(p)/d) = x^(k*d*phi(p)/d) = x^(k*phi(p)) = 1 (mod p)
```

# Left to right: if a^(phi(p)/gcd(m, phi(p))) = 1 (mod p), then a is an mth power residue

Let `d = gcd(m, phi(p))` and m = k * d for some integer k. We know that gcd(k, phi(p)) = 1. Otherwise, d could be bigger.

Let g be a generator of `Z_p*`.

Let `g^b = a (mod p)`.

Then, the equation:
```
a^(phi(p)/d) = 1 (mod p)
```
Implies:
```
g^(b*phi(p)/d) = g^0 (mod p)
b*phi(p)/d = 0 (mod phi(p))
```

Meaning that phi(p) divides `b*phi(p)/d`. This means that b/d is an integer,
so d divides b.
```
b = c * d, for some integer c. However, c might not be unique.
```
Then:
```
a = g^b = (g^c)^d (mod p)
```

From before, we know that h^k = g^c (mod p) and gcd(m, phi(p)) divides c, then h has gcd(k, phi(p)) distinct solutions.

Since gcd(m, phi(p)) = 1, h can be uniquely determined from g, c, and k.
Now we can rewrite a:
```
a = (g^c)^d = (h^k)^d = h^(k*d) = h^m (mod p)
```
Which shows that h is the mth root of a. Then, a is an mth power residue.

---

# If g is a quadtratic residue modulo p, then, in can't be a generator, for p > 2

For g to be a generator, the smallest non-zero m such that g^m = 1 (mod p) should be p - 1.

If g is a quadratic residue, then x^2 = g (mod p).

But then (applying Euler's theorem):
    g^((p-1) / 2) = (x^2)^((p-1) / 2) = x^(p-1) = 1 (mod p)

But (p-1) / 2 < p - 1. So g can't be a generator.

---

# If g is an dth power residue modulo p, for a divisor d > 1 of phi(p), g can't be a generator, for p > 2

This is identical to the proof for quadtratic residues. This is a generalization.

Assume g is a generator. Then, the smallest non-zero m for g^m = 1 (mod p) is m = phi(p).

If g is a dth power residue, then:
```
g^(phi(p) / gcd(d, phi(p))) = g^(phi(p)/d) = 1 (mod p)
```

If d > 1, then phi(p) / d  < phi(p), which contradicts with g being a generator.

---

# If, for any divisor d > 1 of phi(p), h is not a dth power residue mod p, then h is a generator, for p > 2

For h to be a generator, h^m = 1 (mod p) has to have the smallest non-zero solution m = phi(p).

Asssume there exists n < phi(p) such that h^n = 1 (mod p), and n is minimal.
The powers of h generate a subgroup of size n. From Lagrange's theorem, we know that the size of the subgroup must divide the size of the parent group `Z_p*`.

Since `|z_p*| = phi(p)`, n divides phi(p). This means that `d = phi(p)/n` is a divisor of phi(p). Conversely, `n = phi(p)/d`
Knowing that n < phi(p), then d > 1.

Looking back at the equation satisfied by n:
```
h^n = h^(phi(p)/d) = 1 (mod p)
```

This means that h is a dth power residue, which contradicts with the hypothesis.
So, we can say that the smallest m such that h^m = 1 (mod p) is phi(p). In conclusion, h is a generator of `Z_p*`.  

```
g^m = g^0 (mod p)
m = 0 (mod phi(p))
```

---

# The number of generators modulo p is phi(phi(p)).

We can prove this by using the last two lemmas.

## Upper bound

The first lemma gives us an upper bound:
> If g is an dth power residue modulo p, for a divisor d > 1 of phi(p), g can't be a generator
Using its negation:
> If g is a generator, then g is not a dth power residue modulo p, for any divisor d > 1 of phi(p)

Let h be a generator. Then {h^0, h^1, ..., h^phi(p)} is `Z_p*`.

Assume gcd(m, phi(p)) = d. d > 1, and m = k * d, for some integer k.
```
h^m = = h^(k*d) = (h^k)^d (mod p)
```
Which means that h^m is a dth power residue. The number of such m's, for d > 1,
is exactly phi(p) - phi(phi(p)). That's because phi(phi(p)) counts the numbers
m for which gcd(m, phi(p)) = 1.

So, we know that out of phi(p), phi(p) - phi(phi(p)) numbers in `Z_p*` can't
be generators.

```
number of generators <= phi(phi(p))
```

## Lower bound

Using the second lemma:
> If, for any divisor d > 1 of phi(p), h is not a dth power residue mod p, then h is a generator, for p > 2

Again, taking a generator h, and looking at {h^0, ..., h^phi(p)}, if h^m is not
a power residue, we can say that gcd(m, phi(p)) = 1.
Then, h^m is a generator. The amount of numbers m such that gcd(m, phi(p)) = 1 is phi(phi(p)).

````
phi(phi(p)) <= number of generators
```

## Conclusion

Using the 2 bounds, we can conclude that the number of generators is phi(phi(p)).
