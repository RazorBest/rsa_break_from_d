# Decomposing public modulus N by knowing RSA private exponent d

In RSA, the public key is generated by taking two primes, p and q, and setting
N = p * q. Given n, it is a hard problem to find p and q in the right conditions.

Then, $d$ is the inverse of the public exponent, $e$, modulo $\phi(n)$, where
$\phi(n) = \phi(pq) = \phi(p) \cdot \phi(q) = (p - 1)(q - 1)$.

Similarly, d is hard to compute if we don't know the prime decomposition
of n. But if we know p and q, d becomes trivial to compute.

The question is: if d gets revealed, can we recover p and q?

## The algorithm construction

If you don't need to understand how the algorithm works, you can jump straight to the [Source Code](#the-source-code).

This algorithm tries to find a non-trivial square root of 1 mod $n$. Generally, this is a hard problem. But we can create a process that
generates square roots of 1. And, with a high probability those square roots are non-trivial. One non-trivial square root is sufficient to recover $p$ and $q$.

Looking at the definition of $d$:
```math
\begin{align*}
& d \equiv e^{-1} \ (\text{mod } \phi(n)) \\
& de \equiv 1 \ (\text{mod } \phi(n))
\end{align*}
```

Which can be written using the quotient remainder theorem:
```math
\begin{align*}
& de = c \cdot \phi(n) + 1, \text{ for some integer c} \\
& de - 1 = c \cdot phi(n)
\end{align*}
```

Let $k = de - 1 = c \cdot \phi(n)$.

From Euler's theorem, we know that:
```math
g^k \equiv g^{c\cdot \phi(n)} \equiv (g^c)^{\phi(n)} \equiv 1 \ (\text{mod } n) 
```

Until now, we used equations that were very common. The trick is the following:
look at $g^{k/2}$.

Assuming $p$ and $q$ are non-trivial primes, then they are odd. This makes
$\phi(n) = (p - 1)(q - 1)$ an even number. Then, we know that $k / 2$ can be
easily computed.

We will introduce the variable $a$:
```math
a \equiv g^{k/2} \ (\text{mod } n) 
```

Then we can say the following:
```math
a^2 \equiv g^k = 1 \ (\text{mod } n) 
```

Which means that $a$ is a square root of 1. This refers to the known quadratic
residuosity problem. The theory says that for a prime $p$, the equation
$a^2 \equiv x \ (\text{mod } p)$ has either 0 or 2 solutions in $a$. Particularly, $a^2 \equiv 1 \ (\text{mod } p)$ has the solutions $a \equiv 1 \ (\text{mod } p)$ and $a \equiv -1 \ (\text{mod } p)$.

But our modulus is not prime. It's a product of primes. However, equations
modulo n are also true modulo p and q:
```math
\begin{align*}
& a^2 = 1 (\text{mod } p) \\
& a^2 = 1 (\text{mod } q)
\end{align*}
```

But, in each case, we have two solutions. For the first equation:
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } p) \\
& \text{or} \\
& a \equiv -1 \ (\text{mod } p)
\end{align*}
```
And
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } q) \\
& \text{or} \\
& a \equiv -1 \ (\text{mod } q)
\end{align*}
```
Since the results between $p$ and $q$ are independent, there are 4 possible
combinations. We will use the notation $a = (x, y)$, meaning:
```math
\begin{align*}
& a \equiv x \ (\text{mod } p), \text{ for } 0 \leq x < p \\
& \text{and} \\
& a \equiv y \ (\text{mod } q), \text{ for } 0 \leq y < q
\end{align*}
```

Then the possible combinations are:
```math
\begin{align*}
& a = (1, 1) \\
& a = (1, -1) \\
& a = (-1, 1) \\
& a = (-1, -1)
\end{align*}
```

Now, the last theorem that we need is the Chinese Remained Theorem (CRT). This
tells us that given some equalities modulo some numbers, if the numbers
are coprime, then there exists a unique solution modulo the product of
all the numbers, that satisfies the equation.

In our case, knowing:
```math
\begin{align*}
& a \equiv x \ (\text{mod } p) \\
& a \equiv y \ (\text{mod } q) \\
\end{align*}
```
Then:
```math
a \equiv z \ (\text{mod } pq), \text{  where z is uniquely determined from} x, y, p \text{ and } q
```

This means that $a = (x, y)$ can be mapped to exactly one element modulo $n$.

But $(1, 1)$ and $(-1, -1)$ are trivial to find.
```math
\begin{align*}
& a = (1, 1) \text{ leads to } a \equiv 1 \ (	\text{mod } n) \\
& a = (-1, -1) \text { leads to } a \equiv -1 \ (	\text{mod } n) 
\end{align*}
```
You can check that by looking at the solution and verify that it has the
expected values mod p and mod q.

However, $a = (1, -1)$ and $a = (-1, 1)$ have non-trivial solutions modulo $n$. In
fact, we should already know $p$ and $q$ to calculate them.

But earlier, we said that $a$, which we can compute, is one of the square
roots of 1 mod $n$: $(1, 1)$, $(-1, -1)$, $(1, -1)$, $(-1, 1)$.
And it is computed by taking an arbitrary $g$ from the group, and setting $a = g^{k/2}$.

What we hope is that $a = g^{k/2}$ is not a trivial root. For
example, let's assume that $a = (1, -1)$. Which means:
```math
\begin{align*}
& a \equiv 1 \ (\text{mod } p) \\
& a \equiv -1 \ (\text{mod } q)
\end{align*}
```

Then:
```math
\begin{align*}
& a - 1 \equiv 0 \ (\text{mod } p) \\
& a - 1 \equiv -2 \ (\text{mod } q)
\end{align*}
```

Which means that $a-1$ is divisible by $p$, but not by $q$. This is perfect!
We can take the gcd($n$, $a-1$) and we will get $p$. This goes similarly when
$a = (-1, 1)$, in which case, gcd($n$, $a-1$) will yield $q$.

What if $a = 1$? What we can try is to set $a$ to:
```math
\begin{align*}
& a = g^{k/2^f} \text{ mod } n, \\
& \text{where } f \text{ is the biggest integer such that } 2^f \text{ divides } k, \\
& \text{and } a^2 \equiv 1 \ (	\text{mod } n) 
\end{align*}
```

Let $m = k / (2^{f-1})$. Then $g^m = 1 \ (	\text{mod } n)$  and $a = g^{m/2}$ is a square root of 1.

This process finds an exponent for which $a$ might not be 1. If $a$ isn't a non-trivial root, choose
another $g$ and try again.

What I can guarantee is that it will take you a finite amount of expected trials to find
a non-trivial square root.

At this point you have everything you need to write the python algorithm. You can jump directly to the [Source Code](#the-source-code).

But, maybe you're curios what's the success rate of this algorithm. What
if choosing the right g is also a hard task? The next section is dedicated
to answering this question.


---


## The runtime of the algorithm

Let g be a random element from $\mathbb{Z}_n^*$.

Let $k = ed - 1 = c\phi(n) = c(p-1)(q-1)$.

In the algorithm, we look at $g^{k / 2^f} \ (\text{mod } n)$ until its value is not 1, or until the division can't be done anymore.
Each iteration step can be described by:
```math
\begin{align*}
& m_x = k / 2^x,\ x \geq 0 \\
& m_x / 2 = m_{x+1}
\end{align*}
```
And the iteration stops when $m_{x+1}$ is odd or $g^{m_{x}/2} \equiv 1\ (\text{mod } n)$

Let $m = m_f$, such that either m is odd or $g^{m/2} = 1 (\ ( \text{mod } n) )$.

We will look at some interesting values of $m_x$. First, rewrite k by extracting the powers of 2 outside:
```math
\begin{align*}
&\text{Let } a, r\in \mathbb{Z}: \phi(p) = 2^a \cdot r, r \text{ is odd} \\
&\text{Let } b, s\in \mathbb{Z}: \phi(q) = 2^b \cdot s, s \text{ is odd} \\
&\text{Let } d, t\in \mathbb{Z}: c = 2^d \cdot t, t \text{ is odd}
\end{align*}
```
Without loss of generality, assume $a \leq b$.
```math
k = c \cdot \phi(n) = c \cdot \phi(p) \cdot \phi(q) = 2^{a+b+d} \cdot rst
```

### Analysing x <= d + a
If $x <= d + a$, then $g^{m_x} \equiv 1 \ (\text{mod } n)$.

To prove that, we look at the value of $g^{m_x}$ modulo p and q:
```math
\begin{align*}
& x \leq d + a \rightarrow x = d + a - \Delta, \Delta \geq 0 \\
& m_x = k / 2^x = \frac{2^{a+b+d} \cdot rst}{2^{d+a-\Delta}} = 2^{b+\Delta}\cdot rst
\end{align*}
```
Rewriting according to q:
```math
\begin{align*}
& m_x = 2^\Delta \cdot rt \cdot 2^b\cdot s = 2^\Delta rt\cdot \phi(q) \\
& g^{m_x} \equiv g^{2^\Delta rt\cdot \phi(q)} \equiv 1 \ (\text{mod } q) \text{ (Euler's theorem)}
\end{align*}
```
Rewriting according to p:
```math
\begin{align*}
& m_x = 2^{\Delta+b-a} \cdot st \cdot 2^a r = 2^{\Delta+b-a} rt\cdot \phi(p), b-a>=0 \\
& g^{m_x} \equiv g^{2^{\Delta+b-a} rt\cdot \phi(p)} \equiv 1 \ (\text{mod } p) \text{ (Euler's theorem)}
\end{align*}
```

From the two equations:
```math
\begin{align*}
& g^{m_x} \equiv 1 \ (	\text{mod } p) \\
& g^{m_x} \equiv 1 \ (	\text{mod } q) 
\end{align*}
```
we can apply the CRT for $n = p\cdot q$:
```math
g^{m_x} \equiv 1 \ (	\text{mod } n) 
```

Next, we'll look at $x = d + a + 1$. However, it will be split in two cases: $a = b$, and $a < b$.

### First case: a < b

Let $x = d + a + 1$.

If $a < b$, then $a <= b - 1$. We can write $b-1$ as $b - 1 = a + \Delta, \Delta >= 0$.

```math
m_x = 2^{b - 1} \cdot rst = 2^{a + \Delta}\cdot rst
```
Looking at $g^{m_x} \text{ mod } p$:
```math
g^{m_x} \equiv g^{2^{\Delta} \cdot st 2^{a} \cdot r} \equiv g^{2^\Delta st\cdot  \phi(p)} \equiv 1 \ (\text{mod } p)
```

However, for mod $q$, the two's exponent is too small, as $rst$ is odd.
Multiplying by 2 should be enough to get back to $\phi(q)$:
```math
m_x = rt\cdot 2^b s / 2 = rt\cdot \phi(q) / 2
```

What we hope is that $g$ is a quadratic non-residue mod q. Assuming this, and using Euler's criterion and the fact that $rt$ is odd:
```math
g^{m_x} \equiv g^{rt\cdot phi(q) / 2} \equiv (g^{phi(q) / 2})^{rt} \equiv (-1)^{rt} \equiv -1 \ (\text{mod } q)
```

This is great! We've got a value that's $1$ mod $p$ and $-1$ mod $q$, which we can also compute modulo $n$.
This will be a non-trivial square root.

However, this happens only when $g$ is a quadratic non-residue mod $q$. Half of the elements are non-residues.

So, the chance of this happening, when $a < b$, is 1/2.

### Second case: a = b

Let x = d + a + 1

This case is a little different, because we can't guarantee that $g^{m_x}$ will be $1 \text{ mod } p$ or $1 \text{ mod } q$.
However, there is still a chance.

```math
m_x = 2^{b-1} \cdot rst
```

Now, we'll assume that g is a quadratic residue mod p, and a quadratic non-residue mod q.
Express $m_x$ using $\phi(p)$:
```math
m_x = 2^{b} \cdot rst / 2 = st \cdot \phi(p) / 2
```
Using Euler's criterion:
```math
g^{m_x} \equiv g^{st \cdot \phi(p) / 2} \equiv (g^{\phi(p) / 2})^{st} \equiv 1^{st} \equiv 1 \ (\text{mod } p)
```

Then, express $m_x$ using $\phi(q)$
```math
m_x = 2^{b} \cdot rst / 2 = rt \cdot \phi(q) / 2
```
Using Euler's criterion, and the fact that $st$ is odd:
```math
g^{m_x} \equiv g^{rt \cdot \phi(q) / 2} \equiv (g^{\phi(q) / 2})^{rt} \equiv (-1)^{st} \equiv -1 \ (\text{mod } q)
```

This means that $g^{m_x}$ is a non-trivial square root mod n.

Conversely, we can also assume that g is a quadratic non-residue mod q, and a quadratic residue mod q.

Since the value of $g$ mod p and mod q are independent because of the CRT, we can just multiply the probabilities.

The chance of g having different residucity mod p and q is:
```math
\frac{1}{2}\cdot\frac{1}{2} + \frac{1}{2}\cdot\frac{1}{2} = \frac{1}{2}
```

## Conclusion

We can conclude that, when $x <= d + a$, $g^{m_x} = 1 \ (	\text{mod } n) $. Also $m_x$ is even, because $b > 0$.
So the algorithm won't stop because k can't be divided anymore. But $g^m_x/2 = g^{m_{x+1}}$, for which x+1 = a+b+1.
There is a $1/2$ chance that $g^{m_{x+1}}$ will be a non-trivial root.

The algorithm can continue after $x = d + a$ with a 50% chance. And the probability could be tightened up,
depending on the values of a and b, and looking at 2th power residues. But the bound is good enough, because,
in case of failure, the algorithm retries with a new g.

The expected number of g's to be tried is less than 2.

To have a 0.999 probability of success, 10 trials are enough.

# The source code
```python
from itertools import combinations
from math import gcd
from random import randint


def break_rsa_from_d(n: int, e: int, d: int):
    k = d*e - 1

    while True:
        g = random.randint(1, n - 1)
        # This is just a mathematical check
        # The chance for this to happen is roughly 2*sqrt(n)/n. Negligible for n >= 1024.
        if (gcd(g, n)) != 1:
            p = gcd(g, n)
            return p, n // p

        # g**k must always be 1
        # assert pow(g, k, n) == 1
        
        f = 1
        while k % 2**(f+2) == 0 and pow(g, k // 2**(f + 1), n) == 1:
            f += 1

        m = k // (2**f)

        root = pow(g, m // 2, n)

        # From the construction, root is  a square root of 1.
        # In Z_n, for n = p * q, the square root of 1 has 4 different solutions
        # Two of the solutions are 1 and -1. The other two are called non-trivial solutions.
        # We wan't to find a non-trivial square root of 1.

        if root != n - 1 and root != 1:
            p = gcd(n, root - 1)
            # assert p > 1
            return p, n // p


def main():
    p = 29619082031781708758789445286032309089689245581404437540274962433
    q = 36201100261066532927409322016261711109620189043938756993669398529
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 13
    d = pow(e, -1, phi)

    print(break_rsa_from_d(n, e, d))


if __name__ == "__main__":
    main()
```
